// Generated by generate.go; do not edit manually
package inMemoryDatabase

import (
	"subLease/src/server/domain"
	"subLease/src/server/database"
)

{{ $pascalCased := .Entity | PascalCase }}
{{ $camelCased  := .Entity | CamelCase }}

func (d InMemoryDatabase) Get{{ $pascalCased }}s() []domain.{{ $pascalCased }} {
	return d.{{ $camelCased }}s
}

func (d InMemoryDatabase) Get{{ $pascalCased }}(id int) (domain.{{ $pascalCased }}, bool) {
	if {{ $camelCased }}, found := find{{ $pascalCased }}ById(d.{{ $camelCased }}s, id); found {
		return *{{ $camelCased }}, found
	}
	return domain.{{ $pascalCased }}{}, false
}

func (d InMemoryDatabase) Get{{ $pascalCased }}sById(ids []int) []domain.{{ $pascalCased }} {
	var found{{ $pascalCased }}s []domain.{{ $pascalCased }}
	for _, id := range ids {
		if {{ $camelCased }}, found := find{{ $pascalCased }}ById(d.{{ $camelCased }}s, id); found {
			found{{ $pascalCased }}s = append(found{{ $pascalCased }}s, *{{ $camelCased }})
		}
	}
	return found{{ $pascalCased }}s
}

func find{{ $pascalCased }}ById({{ $camelCased }}s []domain.{{ $pascalCased }}, id int) (*domain.{{ $pascalCased }}, bool) {
	for _, {{ $camelCased }} := range {{ $camelCased }}s {
		if {{ $camelCased }}.Id == id {
			return &{{ $camelCased }}, true
		}
	}
	return nil, false
}

func (d *InMemoryDatabase) Create{{ $pascalCased }}({{ $camelCased }} domain.{{ $pascalCased }}) int {
    d.{{ $camelCased }}Counter++
    {{ $camelCased }}.Id = d.{{ $camelCased }}Counter
	d.{{ $camelCased }}s = append(d.{{ $camelCased }}s, {{ $camelCased }})
	return {{ $camelCased }}.Id
}

func (d *InMemoryDatabase) Update{{ $pascalCased }}(id int, {{ $camelCased }}Update database.{{ $pascalCased }}Update) (domain.{{ $pascalCased }}, error) {
    entityToReturn := domain.{{ $pascalCased }}{}
    var errorToReturn error
	if i := indexOf{{ $pascalCased }}(d.{{ $camelCased }}s, id); i != -1 {
		updated, err := {{ $camelCased }}Update.Update{{ $pascalCased }}WithValuesFrom(d.{{ $camelCased }}s[i], d)
		if err != nil {
		    errorToReturn = err
		} else {
	        d.{{ $camelCased}}s[i] = updated
            entityToReturn = updated
		}
	} else {
	    errorToReturn = errors.New("no {{ $pascalCased }} with that id was found")
	}
	return entityToReturn, errorToReturn
}

func indexOf{{ $pascalCased }}({{ $camelCased }}s []domain.{{ $pascalCased }}, id int) (int) {
	for i, {{ $camelCased }} := range {{ $camelCased }}s {
		if {{ $camelCased }}.Id == id {
			return i
		}
	}
	return -1
}

func (d* InMemoryDatabase) Delete{{ $pascalCased }}(id int) (domain.{{ $pascalCased }}, bool) {
	{{ $camelCased }}ToRemove := domain.{{ $pascalCased }}{}
	found := false
	j := 0
	for _, {{ $camelCased }} := range d.{{ $camelCased }}s {
		if {{ $camelCased }}.Id != id {
			d.{{ $camelCased }}s[j] = {{ $camelCased }}
			j++
		} else {
			{{ $camelCased }}ToRemove = {{ $camelCased }}
			d.{{ $camelCased}}Counter--
			found = true
		}
	}
	d.{{ $camelCased }}s = d.{{ $camelCased }}s[:j]
	return {{ $camelCased }}ToRemove, found
}

