// Generated by generate.go; do not edit manually
package inMemoryDatabase

import (
	"errors"
	"subLease/src/server/database"
	"subLease/src/server/domain"
)

func (d InMemoryDatabase) GetOwners() []domain.Owner {
	return d.owners
}

func (d InMemoryDatabase) GetOwner(id int) (domain.Owner, bool) {
	if owner, found := findOwnerById(d.owners, id); found {
		return *owner, found
	}
	return domain.Owner{}, false
}

func (d InMemoryDatabase) GetOwnersById(ids []int) []domain.Owner {
	var foundOwners []domain.Owner
	for _, id := range ids {
		if owner, found := findOwnerById(d.owners, id); found {
			foundOwners = append(foundOwners, *owner)
		}
	}
	return foundOwners
}

func findOwnerById(owners []domain.Owner, id int) (*domain.Owner, bool) {
	for _, owner := range owners {
		if owner.Id == id {
			return &owner, true
		}
	}
	return nil, false
}

func (d *InMemoryDatabase) CreateOwner(owner domain.Owner) int {
	d.ownerCounter++
	owner.Id = d.ownerCounter
	d.owners = append(d.owners, owner)
	return owner.Id
}

func (d *InMemoryDatabase) UpdateOwner(id int, ownerUpdate database.OwnerUpdate) (domain.Owner, error) {
	entityToReturn := domain.Owner{}
	var errorToReturn error
	if i := indexOfOwner(d.owners, id); i != -1 {
		updated, err := ownerUpdate.UpdateOwnerWithValuesFrom(d.owners[i], d)
		if err != nil {
			errorToReturn = err
		} else {
			d.owners[i] = updated
			entityToReturn = updated
		}
	} else {
		errorToReturn = errors.New("no Owner with that id was found")
	}
	return entityToReturn, errorToReturn
}

func indexOfOwner(owners []domain.Owner, id int) int {
	for i, owner := range owners {
		if owner.Id == id {
			return i
		}
	}
	return -1
}

func (d *InMemoryDatabase) DeleteOwner(id int) (domain.Owner, bool) {
	ownerToRemove := domain.Owner{}
	found := false
	j := 0
	for _, owner := range d.owners {
		if owner.Id != id {
			d.owners[j] = owner
			j++
		} else {
			ownerToRemove = owner
			d.ownerCounter--
			found = true
		}
	}
	d.owners = d.owners[:j]
	return ownerToRemove, found
}
